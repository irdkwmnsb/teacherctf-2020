# Ron-Adi-Leo

## Описание

e = 65537  
n = 282440654389  
c = 101890472577

Не забудьте обернуть флаг в ```SICAMP{}```!

## Решение

Характерные обозначения ```e``` и ```n```, а также название намекают, что таск на шифр RSA (название шифра является аббревиатурой от фамилий троих создателей, а в название таска вынесены их имена). Под обозначением ```c``` скрывается зашифрованный флаг.

Первый шаг - факторизация ```n```, с чем успешно справляется [Wolfram Alpha](https://www.wolframalpha.com/).

Далее необходимо вычислить функцию Эйлера от полученных простых множителей ```p``` и ```q```:

```φ=(p-1)×(q-1)```

Получаем φ = 282423868524

```e``` дано в условии как часть публичного ключа. Чтобы получить приватный ключ (пару значений ```d``` и ```n```), нужно вычислить число, обратное ```e``` по модулю ```φ```. Это можно сделать, например, при помощи python и библиотеки [gmpy](https://pypi.org/project/gmpy/):

```
>>> import gmpy
>>> e = 65537
>>> phi = 282423868524
>>> d = gmpy.invert(e, phi)
>>> d
mpz(52501182389)
```

Таким образом мы получили приватный ключ: ```(d, n) = (52501182389, 282440654389)```

Чтобы расшифровать сообщение, необходимо ```c``` возвести в степень ```d``` по модулю ```n```. Продолжим вычисления с помощью python, используя встроенную функцию ```pow```:

```
>>> c = 101890472577
>>> d = 52501182389
>>> n = 282440654389
>>> m = pow(c, d, n)
>>> m
7025515
```

Полученное число - это флаг в формате dec (десятичная система счисления). Для удобства можно сначала перевести его [в hex](https://www.rapidtables.com/convert/number/decimal-to-hex.html), а затем уже в [ascii text](https://www.rapidtables.com/convert/number/hex-to-ascii.html).

Полученный текст необходимо обернуть в ```SICAMP{}```


**Флаг:** SICAMP{k3k}
